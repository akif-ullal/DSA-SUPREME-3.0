class Solution {
public:

    vector<string>solveRec(string&s,unordered_map<string,bool>&mapp,int start)
    {
        if(start==s.size())
        {
            return {""};
        }
        string word="";
        vector<string>ans;
        for(int i=start;i<s.size();i++)
        {
            word.push_back(s[i]);
            if(mapp.find(word)==mapp.end())
            {
                continue;
            }
            

            auto right=solveRec(s,mapp,i+1);

            for(auto eachRightPart:right)
            {
                string each;

                if(eachRightPart.size() > 0)
                {
                    each=" "+eachRightPart;
                }
                ans.push_back(word+each);
            }
    
        }
        return ans;
    }

    vector<string>solveMem(string&s,unordered_map<string,bool>&mapp,int start,unordered_map<int,vector<string>>&dp)
    {
        if(start==s.size())
        {
            return {""};
        }

        if(dp.find(start)!=dp.end())
        {
            return dp[start];
        }

        string word="";
        vector<string>ans;
        for(int i=start;i<s.size();i++)
        {
            word.push_back(s[i]);
            if(mapp.find(word)==mapp.end())
            {
                continue;
            }
            

            auto right=solveMem(s,mapp,i+1,dp);

            for(auto eachRightPart:right)
            {
                string each;

                if(eachRightPart.size() > 0)
                {
                    each=" "+eachRightPart;
                }
                ans.push_back(word+each);
            }
    
        }
        dp[start]=ans;
        return dp[start];
    }
    vector<string> wordBreak(string s, vector<string>& wordDict) {

        unordered_map<string,bool>mapp;

        for(auto &each:wordDict)
        {
            mapp[each]=true;
        }

        unordered_map<int,vector<string>>dp;
        vector<string>ans=solveMem(s,mapp,0,dp);
        return ans;
    }
};
